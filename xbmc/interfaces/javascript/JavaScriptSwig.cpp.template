<%
/*
 *      Copyright (C) 2012 Team XBMC
 *      http://www.xbmc.org
 *
 *  This Program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2, or (at your option)
 *  any later version.
 *
 *  This Program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with XBMC; see the file COPYING.  If not, see
 *  <http://www.gnu.org/licenses/>.
 *
 */
%>
<%
import Helper
import SwigTypeParser
import JavaScriptTools
import MethodType

import groovy.xml.XmlUtil
import groovy.text.SimpleTemplateEngine
import java.util.regex.Pattern

/**
 * All of the method nodes and all of the class nodes are used several
 * times over, so they are pulled out once here.
 */

// initialize the SwigTypeParser with the module's typetables
module.findAll( { it.name() == 'typetab' } ).each {  SwigTypeParser.appendTypeTable(it) }

methods = module.depthFirst().findAll { it.name() == 'function' || it.name() == 'constructor' || it.name() == 'destructor' }
classes = module.depthFirst().findAll { it.name() == 'class' }

Helper.setup(classes,
    /**
     * This is meant to contain mini-templates for converting the return type
     * of the native call to be returned to the javascript caller.
     */
    [ 'void' : '${result} = v8::Handle<v8::Value>();',
      'long': '${result} = v8::Integer::New(${api});',
      'unsigned long': '${result} = v8::Uint32::New(${api});',
      'bool': '${result} = v8::Boolean::New(${api});',
      'long long': '${result} = v8::Integer::New(${api});',
      'int': '${result} = v8::Integer::New(${api});',
      'double': '${result} = v8::Number::New(${api});',
      'float': '${result} = v8::Number::New(${api});',
      'String' : '${result} = v8::String::New(${api}.c_str());',
      'p.q(const).char' : '${result} = v8::String::New(${api});',
      (Pattern.compile('''(p.){0,1}std::vector<\\(.*\\)>''')) : new File('typemaps/javascript.vector.outtm'),
      (Pattern.compile('''(p.){0,1}Tuple<\\(.*\\)>''')) : new File('typemaps/javascript.Tuple.outtm'),
    ], '${result} = makePythonInstance(${api},&Py${Helper.findFullClassName(classnode).replaceAll(\'::\',\'_\')}_Type,&Ty${Helper.findFullClassName(classnode).replaceAll(\'::\',\'_\')}_Type,true);',
    /**
     * This is meant to contain mini-templates for converting the parameter types
     * of the native call to be converted from the javascript types provided by the caller.
     */
    [
      'p.char' : '${api} = *v8::String::Utf8Value(${slarg});',
      'String' : '${api} = *v8::String::Utf8Value(${slarg});',
      'bool' : '${api} = ${slarg}->BooleanValue();',
      'int' : '${api} = ${slarg}->Int32Value();',
      'unsigned int' : '${api} = ${slarg}->Uint32Value();',
      'long' : '${api} = (long)${slarg}->IntegerValue();',
      'unsigned long' : '(unsigned long)${slarg}->IntegerValue();',
      'double' : '${api} = ${slarg}->NumberValue();',
      'float' : '${api} = (float)${slarg}->NumberValue();',
      'long long' : '${api} = (long long)${slarg}->NumberValue();',
      (Pattern.compile('''(p.){0,1}std::vector<\\(.*\\)>''')) : new File('typemaps/javascript.vector.intm'),
      (Pattern.compile('''(p.){0,1}Tuple(3){0,1}<\\(.*\\)>''')) : new File('typemaps/javascript.Tuple.intm'),
      // I shouldn't need both of these but my parser doesn't resolve namespaces within
      //  parameter declarations. TODO: Maybe I should fix this.
      'r.q(const).Dictionary' : new File('typemaps/javascript.dict.intm'),
      'r.q(const).XBMCAddon::Dictionary' : new File('typemaps/javascript.dict.intm'),
      (Pattern.compile('''(p.){0,1}std::map<\\(.*\\)>''')) : new File('typemaps/javascript.map.intm'),
    ], '${api} = (${swigTypeParser.SwigType_str(ltype)})retrieveApiInstance(${slarg},"${ltype}","${helper.findNamespace(method)}","${helper.callingName(method)}");' )

//println 'this: ' + this.binding.getVariables()
    
void doClass(clazz)
{
  String className = PythonTools.getClassNameAsVariable(clazz)
    
  List normalMethods = clazz.function.findAll { !it.@name.startsWith("operator ") }
  List operators =  clazz.function.findAll { it.@name.startsWith("operator ") }
  
  // TODO
%>
  class ${className}
  {
  public:
    static v8::Handle<v8::FunctionTemplate> Init(v8::Isolate *isolate)
    {
      v8::Locker lock(isolate);
      v8::Isolate::Scope isolate_scope(isolate);
      v8::HandleScope handle_scope;
      
      // Create a new function template
      v8::Handle<v8::FunctionTemplate> tmpl = v8::FunctionTemplate::New();
      tmpl->SetClassName(V8_STR("${module.@name}"));

      // Get the ObjectTemplate
      v8::Local<v8::ObjectTemplate> inst = tmpl->InstanceTemplate();
      inst->SetInternalFieldCount(1);
      // TODO: inst->SetAccessor(String::New("addonid"), getAddonId);

      // Get the prototype template
      v8::Handle<v8::ObjectTemplate> prt = tmpl->PrototypeTemplate();
      // TODO: prt->Set("log", FunctionTemplate::New(Xbmc::log));

      return handle_scope.Close(tmpl);
    }
    
<%
  normalMethods.each {
    
  }
%>
  };
<%
}

void doMethod(method, MethodType methodType)
{
  boolean isOperator = method.@name.startsWith("operator ")

  if (isOperator)
    return;

  boolean constructor = methodType == MethodType.constructor

  // if we're a constructor, but we're private, then we're outta here
  if (constructor && method.@access != null && method.@access != "public")
    return

  boolean destructor = methodType == MethodType.destructor
  List params = method?.parm
  int numParams = params?.size()
  String clazz = Helper.findFullClassName(method)
  String returns = constructor ? 'p.' + clazz : (destructor ? 'void' : Helper.getReturnSwigType(method))
  Node classnode = Helper.findClassNode(method)
  String classNameAsVariable = clazz == null ? null : JavaScriptTools.getClassNameAsVariable(classnode)
  
%>
  static V8_<% 
  if (methodType == MethodType.constructor) { %>CTOR<% }
  else if (methodType == MethodType.destructor) { %>DTOR<% }
  else { %>FUNCTION<% } 
  %>(${module.@name}_${JavaScriptTools.getJSMethodName(method,methodType)})
  {
    TRACE;
<%  if (numParams > 0)
    {
      params.each { 
%>         
    ${SwigTypeParser.SwigType_str(SwigTypeParser.convertTypeToLTypeForParam(it.@type))} ${it.@name} ${it.@value != null ? ' = ' + it.@value : ''};
    v8::Handle<v8::Value> j${it.@name};
<%    } %>
<%  }
    // now actually invoke the method
    if (returns != "void") { %>    ${SwigTypeParser.SwigType_lstr(returns)} apiResult;<%   }
%>
    try
    {
      
    }
    catch (const XbmcCommons::Exception& e)
    { 
      CLog::Log(LOGERROR, "EXCEPTION: %s", e.GetMessage());
      <% if (!destructor) {  %>return<% } %> V8_ERROR(e.GetMessage());
    }
    catch (...)
    {
      CLog::Log(LOGERROR, "EXCEPTION: Unknown exception thrown from the call \"${Helper.callingName(method)}\"");
      <% if (!destructor) {  %>return<% } %> V8_ERROR("Unknown exception thrown from the call \"${Helper.callingName(method)}\"");
    }
<%
    if (!destructor) { %>
    v8::Handle<v8::Value> result;

    // transform the result
<%
    if (constructor) {
      %>    return args.This();<%
    }
    else {
%>    ${Helper.getOutConversion(returns,'result',method)}<%
    }
 %>

    return result; <% } %>
  } <%
}

void doClassMethodInfo(Node clazz, List initTypeCalls = null)
{ 
  
}

List getAllVirtualMethods(Node clazz)
{
  List ret = []
  ret.addAll(clazz.findAll({ it.name() == 'function' && it.@storage && it.@storage == 'virtual' }))
  if (clazz.baselist) { 
    if (clazz.baselist[0].base) clazz.baselist[0].base.each {
        Node baseclassnode = Helper.findClassNodeByName(module,it.@name,clazz)
        if (baseclassnode && baseclassnode.@feature_director) ret.addAll(getAllVirtualMethods(baseclassnode))
      }
  }
  return ret;
}

%>
/*
 *      Copyright (C) 2005-2012 Team XBMC
 *      http://www.xbmc.org
 *
 *  This Program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2, or (at your option)
 *  any later version.
 *
 *  This Program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with XBMC; see the file COPYING.  If not, write to
 *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 *  http://www.gnu.org/copyleft/gpl.html
 *
 */

// ************************************************************************
// This file was generated by xbmc compile process. DO NOT EDIT!!
//  It was created by running the code generator on the spec file for
//  the module "${module.@name}" on the template file PythonSwig.template.cpp
// ************************************************************************

<%
Helper.getInsertNodes(module, 'begin').each { %>${Helper.unescape(it)}<% }
%>

#include "commons/Exception.h"
#include "interfaces/javascript/v8internal.h"
#include "interfaces/javascript/LanguageHook.h"
#include "interfaces/javascript/swig.h"

<%
Helper.getInsertNodes(module, 'header').each { %>${Helper.unescape(it)}<% }
%>

namespace JavaScriptBindings
{
<%
  List initTypeCalls = []
  List classNameAsVariables = []
%>

<%
  classes.each { clazz -> doClass(clazz) }

  /* TODO
  // types used as method parameter or return values need to be declared
  // as extern if they are unknown types.
  methods.each { if (it.name() != 'destructor') { doMethod(it, (it.name() == 'constructor' ? MethodType.constructor : MethodType.method)); println(); } }
  classes.each { clazz -> doMethod(clazz, MethodType.destructor) }

  classes.each { clazz -> doClassMethodInfo(clazz, initTypeCalls) }
  */
%>

} // end JavaScriptBindings namespace for javascript type definitions

